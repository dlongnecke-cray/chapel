/*
 * Copyright 2020-2026 Hewlett Packard Enterprise Development LP
 * Copyright 2004-2019 Cray Inc.
 * Other additional copyright holders may be indicated within.
 *
 * The entirety of this work is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ChapelProgramRegistration {
  use ChapelBase, CTypes;

  // This is a header defined in the runtime. TODO: Does this do anything?
  require "chpl-program-registration.h";

  // The type of a program ID - this is defined in a runtime header.
  extern type chpl_prg_id = uint(64);

  // Contains all sorts of information that describes a Chapel program.
  // Is described in 'runtime/include/chapel-program-registration.h'.
  // It is intentionally completely opaque here.
  extern type chpl_program_info;

  proc isProgramCompiledAsLibrary param {
    param style = __primitive('get compiler variable', 'libraryStyle');
    return style != 'none';
  }

  proc isProgramLinkedAgainstBuiltinRuntime param {
    param style = __primitive('get compiler variable', 'runtimeStyle');
    return style == 'static';
  }

  // We maintain a program info for each locale.
  record chpl_programInfo {
    var info: chpl_program_info;
    var prepared: bool;

    inline proc type nullId param: uint do return 0;
    inline proc type rootId param: uint do return 1;
    inline proc nullId param do return this.type.nullId;
    inline proc rootId param do return this.type.rootId;

    inline proc id {
      param cname = 'chpl_program_info_id';
      extern cname proc id(const ref chpl_program_info): chpl_prg_id;
      return id(info);
    }

    inline proc ref _callSetter(param name: string, in val) {
      // Use 'const ref val' to avoid any copies at this time.
      param cname = 'chpl_program_info_data_entry_set_' + name;

      // The setter is defined in the runtime and it knows the size in bytes it
      // needs to memcopy from 'data'. Instead, the module code is responsible
      // for passing in a pointer to a type of the correct size!
      extern cname proc setter(ref info: chpl_program_info,
                               data: c_ptrConst(void)): void;
      const ptrToData = c_addrOfConst(val);

      // Invoke the appropriate setter in the module code.
      setter(info=this.info, data=ptrToData);
    }

    inline proc ref setCallback(param name: string) {
      // NOTE: The type need not match up - we just need the local address...
      extern name proc callback(): void;

      // NOTE: This absolutely, should not, under ANY circumstances, create a
      //       Chapel procedure pointer from 'callback'! The only thing that
      //       should be happening here is to cast the local address of the
      //       'callback' to a 'void*'! (Otherwise, everything explodes...)
      const ptr1: c_fn_ptr = __primitive("capture fn", callback, true);
      const ptr2 = ptr1 : c_ptr(void);

      _callSetter(name, ptr2);
    }

    inline proc ref setConstant(param name: string, in val) {
      // TODO: We need to be able to write something like this...
      /*
      // This type is defined in 'chpl-program-registration.h'.
      param type_c_name = name + '_type';
      extern type_c_name type dataType;

      // This value ought to exist and have external linkage.
      // TODO: We can also just use a bogus type...
      extern name const data: dataType;

      _callSetter(name, data);
      */

      _callSetter(name, val);
    }

    inline proc infoForIdHere(prg: chpl_prg_id) {
      param cname = 'chpl_program_info_from_id_here';
      extern cname proc get(prg: chpl_prg_id): c_ptr(chpl_program_info);
      return get(prg);
    }

    inline proc ref prepare(): void {
      if !prepared {
        setProgramInfoDataFieldsHere(this);
        prepared = true;
      }
    }

    inline proc ref registerAsRoot(): bool {
      param cname = 'chpl_program_register_root_here';
      extern cname proc register(ref info: chpl_program_info): c_int;

      prepare();
      const ret = register(info) : bool;

      return ret;
    }

    inline proc ref asPtr() do return c_ptrTo(info);
  }

  pragma "no init"          /** Initialized manually at program startup.  */
  pragma "locale private"   /** One per locale, per program.              */
  var chpl_programInfoHere: chpl_programInfo;

  // TODO: This was generated by a script, but I don't quite have that
  //       wired up into the build pipeline yet. Can I generate a helper
  //       function that sits in a generated module and use that?
  proc setProgramInfoDataFieldsHere(ref info: chpl_programInfo) {
    extern type mainHasArgs_type;
    extern const mainHasArgs: mainHasArgs_type;
    info.setConstant('mainHasArgs', mainHasArgs);
    extern type mainPreserveDelimiter_type;
    extern const mainPreserveDelimiter: mainPreserveDelimiter_type;
    info.setConstant('mainPreserveDelimiter', mainPreserveDelimiter);
    info.setCallback('chpl_program_about');
    info.setCallback('chpl_task_getCommDiagsTemporarilyDisabled');
    info.setCallback('chpl_task_setCommDiagsTemporarilyDisabled');
    extern type chpl_private_broadcast_table_type;
    extern const chpl_private_broadcast_table: chpl_private_broadcast_table_type;
    info.setConstant('chpl_private_broadcast_table', chpl_private_broadcast_table);
    extern type chpl_private_broadcast_table_len_type;
    extern const chpl_private_broadcast_table_len: chpl_private_broadcast_table_len_type;
    info.setConstant('chpl_private_broadcast_table_len', chpl_private_broadcast_table_len);
    extern type chpl_global_serialize_table_type;
    extern const chpl_global_serialize_table: chpl_global_serialize_table_type;
    info.setConstant('chpl_global_serialize_table', chpl_global_serialize_table);
    extern type chpl_globals_registry_type;
    extern const chpl_globals_registry: chpl_globals_registry_type;
    info.setConstant('chpl_globals_registry', chpl_globals_registry);
    extern type chpl_numGlobalsOnHeap_type;
    extern const chpl_numGlobalsOnHeap: chpl_numGlobalsOnHeap_type;
    info.setConstant('chpl_numGlobalsOnHeap', chpl_numGlobalsOnHeap);
    extern type chpl_ftable_type;
    extern const chpl_ftable: chpl_ftable_type;
    info.setConstant('chpl_ftable', chpl_ftable);
    extern type chpl_ftableSize_type;
    extern const chpl_ftableSize: chpl_ftableSize_type;
    info.setConstant('chpl_ftableSize', chpl_ftableSize);
    info.setCallback('chpl_taskRunningCntInc');
    info.setCallback('chpl_taskRunningCntDec');
    info.setCallback('chpl_taskRunningCntReset');
    info.setCallback('CreateConfigVarTable');
    info.setCallback('chpl__initStringLiterals');
    info.setCallback('chpl__init_preInit');
    info.setCallback('chpl__init_PrintModuleInitOrder');
    info.setCallback('chpl__init_ChapelStandard');
    info.setCallback('chpl_gen_main');
    extern type chpl_filenameTable_type;
    extern const chpl_filenameTable: chpl_filenameTable_type;
    info.setConstant('chpl_filenameTable', chpl_filenameTable);
    extern type chpl_filenameTableSize_type;
    extern const chpl_filenameTableSize: chpl_filenameTableSize_type;
    info.setConstant('chpl_filenameTableSize', chpl_filenameTableSize);
    extern type chpl_mem_descs_type;
    extern const chpl_mem_descs: chpl_mem_descs_type;
    info.setConstant('chpl_mem_descs', chpl_mem_descs);
    extern type chpl_mem_numDescs_type;
    extern const chpl_mem_numDescs: chpl_mem_numDescs_type;
    info.setConstant('chpl_mem_numDescs', chpl_mem_numDescs);
    info.setCallback('chpl_memTracking_returnConfigVals');
    extern type chpl_compileCommand_type;
    extern const chpl_compileCommand: chpl_compileCommand_type;
    info.setConstant('chpl_compileCommand', chpl_compileCommand);
    extern type chpl_compileDirectory_type;
    extern const chpl_compileDirectory: chpl_compileDirectory_type;
    info.setConstant('chpl_compileDirectory', chpl_compileDirectory);
    extern type chpl_saveCDir_type;
    extern const chpl_saveCDir: chpl_saveCDir_type;
    info.setConstant('chpl_saveCDir', chpl_saveCDir);
    extern type CHPL_HOME_type;
    extern const CHPL_HOME: CHPL_HOME_type;
    info.setConstant('CHPL_HOME', CHPL_HOME);
    extern type CHPL_CACHE_REMOTE_type;
    extern const CHPL_CACHE_REMOTE: CHPL_CACHE_REMOTE_type;
    info.setConstant('CHPL_CACHE_REMOTE', CHPL_CACHE_REMOTE);
    extern type warnUnstable_type;
    extern const warnUnstable: warnUnstable_type;
    info.setConstant('warnUnstable', warnUnstable);
    extern type CHPL_LLVM_BIN_DIR_type;
    extern const CHPL_LLVM_BIN_DIR: CHPL_LLVM_BIN_DIR_type;
    info.setConstant('CHPL_LLVM_BIN_DIR', CHPL_LLVM_BIN_DIR);
    extern type chpl_filenumSymTable_type;
    extern const chpl_filenumSymTable: chpl_filenumSymTable_type;
    info.setConstant('chpl_filenumSymTable', chpl_filenumSymTable);
    extern type chpl_funSymTable_type;
    extern const chpl_funSymTable: chpl_funSymTable_type;
    info.setConstant('chpl_funSymTable', chpl_funSymTable);
    extern type chpl_sizeSymTable_type;
    extern const chpl_sizeSymTable: chpl_sizeSymTable_type;
    info.setConstant('chpl_sizeSymTable', chpl_sizeSymTable);
    extern type CHPL_UNWIND_type;
    extern const CHPL_UNWIND: CHPL_UNWIND_type;
    info.setConstant('CHPL_UNWIND', CHPL_UNWIND);
    extern type CHPL_INTERLEAVE_MEM_type;
    extern const CHPL_INTERLEAVE_MEM: CHPL_INTERLEAVE_MEM_type;
    info.setConstant('CHPL_INTERLEAVE_MEM', CHPL_INTERLEAVE_MEM);
    info.setCallback('chpl_localeModel_sublocToExecutionSubloc');
    extern type CHPL_COMM_type;
    extern const CHPL_COMM: CHPL_COMM_type;
    info.setConstant('CHPL_COMM', CHPL_COMM);
    extern type CHPL_STACK_CHECKS_type;
    extern const CHPL_STACK_CHECKS: CHPL_STACK_CHECKS_type;
    info.setConstant('CHPL_STACK_CHECKS', CHPL_STACK_CHECKS);
    extern type CHPL_TARGET_PLATFORM_type;
    extern const CHPL_TARGET_PLATFORM: CHPL_TARGET_PLATFORM_type;
    info.setConstant('CHPL_TARGET_PLATFORM', CHPL_TARGET_PLATFORM);
    extern type CHPL_TARGET_MEM_type;
    extern const CHPL_TARGET_MEM: CHPL_TARGET_MEM_type;
    info.setConstant('CHPL_TARGET_MEM', CHPL_TARGET_MEM);
    info.setCallback('chpl__heapAllocateGlobals');
    extern type chpl_finfo_type;
    extern const chpl_finfo: chpl_finfo_type;
    info.setConstant('chpl_finfo', chpl_finfo);
    extern type CHPL_LOCALE_MODEL_type;
    extern const CHPL_LOCALE_MODEL: CHPL_LOCALE_MODEL_type;
    info.setConstant('CHPL_LOCALE_MODEL', CHPL_LOCALE_MODEL);
    extern type CHPL_TARGET_CPU_type;
    extern const CHPL_TARGET_CPU: CHPL_TARGET_CPU_type;
    info.setConstant('CHPL_TARGET_CPU', CHPL_TARGET_CPU);
    extern type CHPL_GASNET_SEGMENT_type;
    extern const CHPL_GASNET_SEGMENT: CHPL_GASNET_SEGMENT_type;
    info.setConstant('CHPL_GASNET_SEGMENT', CHPL_GASNET_SEGMENT);
    info.setCallback('chpl_qio_setup_plugin_channel');
    info.setCallback('chpl_qio_read_atleast');
    info.setCallback('chpl_qio_write');
    info.setCallback('chpl_qio_channel_close');
    info.setCallback('chpl_qio_filelength');
    info.setCallback('chpl_qio_getpath');
    info.setCallback('chpl_qio_fsync');
    info.setCallback('chpl_qio_get_chunk');
    info.setCallback('chpl_qio_get_locales_for_region');
    info.setCallback('chpl_qio_file_close');
    info.setCallback('chpl_mapPtrToIdxHere');
  }

  export proc chpl_prepareProgramInfoHere(): c_ptr(chpl_program_info) {
    ref prg = chpl_programInfoHere;
    prg.prepare();
    return c_ptrTo(prg.info);
  }
}
